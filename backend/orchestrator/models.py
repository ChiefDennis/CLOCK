# /orchestrator/models.py

# This file contains the SQLAlchemy models

from extensions import db
from werkzeug.security import generate_password_hash, check_password_hash
from sqlalchemy.dialects.postgresql import JSONB
from sqlalchemy.sql import func # Import the func object for server-side defaults

class User(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    username = db.Column(db.String(80), unique=True, nullable=False)
    password_hash = db.Column(db.String(512), nullable=False)
    role = db.Column(db.String(20), nullable=False)
    enabled = db.Column(db.Boolean, nullable=False, default=True)

    def set_password(self, password):
        self.password_hash = generate_password_hash(password)

    def check_password(self, password):
        return check_password_hash(self.password_hash, password)

class Log(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    username = db.Column(db.String)
    role = db.Column(db.String)
    method = db.Column(db.String(10))
    endpoint = db.Column(db.String(255))
    status_code = db.Column(db.Integer)
    request_data = db.Column(db.Text)
    response_data = db.Column(db.Text)
    action = db.Column(db.String(255))
    
    # Use a server-side default for timestamps.
    # 'func.now()' is translated to the database's native NOW() function,
    # ensuring the timestamp is generated by the DB upon insertion.
    timestamp = db.Column(
        db.DateTime(timezone=True), 
        server_default=func.now()
    )

    def to_dict(self):
        return {
            "id": self.id,
            "username": self.username,
            "role": self.role,
            "method": self.method,
            "endpoint": self.endpoint,
            "status_code": self.status_code,
            "request_data": self.request_data,
            "response_data": self.response_data,
            "action": self.action,
            "timestamp": self.timestamp.isoformat() if self.timestamp else None
        }

class KeyMetadata(db.Model):
    __tablename__ = "key_metadata"

    id = db.Column(db.Integer, primary_key=True)

    # Identity
    cloud_provider = db.Column(db.String(10), nullable=False, index=True)
    key_id = db.Column(db.String(256), nullable=False, index=True)
    key_arn = db.Column(db.String(1024), nullable=False)

    # Common attributes
    region = db.Column(db.String(64), index=True)
    # This column correctly uses timezone=True for the data type.
    created_at = db.Column(db.DateTime(timezone=True), nullable=False)
    status = db.Column(db.String(64), nullable=False)
    description = db.Column(db.String(1024))
    is_primary = db.Column(db.Boolean, nullable=False, default=False)

    # Detailed attributes
    rotation_enabled = db.Column(db.Boolean, nullable=False, default=False)
    rotation_days = db.Column(db.Integer, nullable=True)
    labels = db.Column(JSONB, nullable=False, default=dict)
    origin = db.Column(db.String(64))
    version = db.Column(db.String(128))
    usage = db.Column(db.String(64))
    algorithm = db.Column(db.String(64))
    protection_level = db.Column(db.String(32))

    # Alarm fields
    last_updated_by = db.Column(db.String(80), nullable=True) # Username who made the change
    last_update_source = db.Column(db.String(20), nullable=True, default='sync') # 'API' or 'sync'

    __table_args__ = (
        db.UniqueConstraint("cloud_provider", "key_id", name="uq_provider_keyid"),
        db.UniqueConstraint("key_arn", name="uq_key_arn"),
    )

    def to_dict(self):
        return {
            "id": self.id,
            "key_id": self.key_id,
            "key_arn": self.key_arn,
            "cloud_provider": self.cloud_provider,
            "created_at": self.created_at.isoformat() if self.created_at else None,
            "status": self.status,
            "description": self.description,
            "is_primary": self.is_primary,
            "rotation_enabled": self.rotation_enabled,
            "rotation_days": self.rotation_days,
            "labels": self.labels,
            "origin": self.origin,
            "region": self.region,
            "version": self.version,
            "usage": self.usage,
            "algorithm": self.algorithm,
            "protection_level": self.protection_level,
            "last_updated_by": self.last_updated_by,
            "last_update_source": self.last_update_source
        }
        
class ModuleStatus(db.Model):
    __tablename__ = "module_status"

    id = db.Column(db.Integer, primary_key=True)
    provider_name = db.Column(db.String(20), unique=True, nullable=False)
    is_enabled = db.Column(db.Boolean, nullable=False, default=True)
    last_synced_at = db.Column(db.DateTime(timezone=True), nullable=True)

    def to_dict(self):
        return {
            "provider_name": self.provider_name,
            "is_enabled": self.is_enabled,
            "last_synced_at": self.last_synced_at.isoformat() if self.last_synced_at else None
        }
    
class PendingAction(db.Model):
    __tablename__ = "pending_actions"

    id = db.Column(db.Integer, primary_key=True)
    action_type = db.Column(db.String(50), nullable=False)  # e.g., 'DELETE_USER', 'DELETE_KEY'
    resource_identifier = db.Column(db.String(255), nullable=False)  # e.g., the user_id or key_id
    status = db.Column(
        db.String(20),
        nullable=False,
        default="PENDING"
    ) 

    created_at = db.Column(db.DateTime(timezone=True), server_default=func.now())
    expires_at = db.Column(db.DateTime(timezone=True), nullable=False)

    created_by_username = db.Column(db.String(80), nullable=False)
    reviewed_by_username = db.Column(db.String(80), nullable=True)  # Who reviewed (approve or deny)
    reviewed_at = db.Column(db.DateTime(timezone=True))

class Alarm(db.Model):
    __tablename__ = "alarms"

    id = db.Column(db.Integer, primary_key=True)
    timestamp = db.Column(db.DateTime(timezone=True), server_default=func.now())
    severity = db.Column(db.String(20), nullable=False) # e.g., 'HIGH', 'MEDIUM', 'INFO'
    event_type = db.Column(db.String(50), nullable=False) # e.g., 'OUT_OF_BAND_CHANGE'
    message = db.Column(db.Text, nullable=False)
    is_acknowledged = db.Column(db.Boolean, default=False, nullable=False)